/* eslint-disable import/no-dynamic-require */
/* eslint-disable global-require */
import { loadingSnippet } from './nativeSdkLoader';

const pathToSdk = '../dist/cdn/legacy/iife/rsa.js';

describe('Test suite for the SDK', () => {
  const xhrMock: any = {
    open: jest.fn(),
    setRequestHeader: jest.fn(),
    onload: jest.fn(),
    onreadystatechange: jest.fn(),
    responseText: JSON.stringify({
      source: {
        config: {},
        id: 'id',
        destinations: [],
      },
    }),
    status: 200,
  };

  xhrMock.send = jest.fn(() => xhrMock.onload());

  const userId = 'jest-user-id';
  const userTraits = {
    'jest-user-trait-key-1': 'jest-user-trait-value-1',
    'jest-user-trait-key-2': 'jest-user-trait-value-2',
  };

  const groupUserId = 'jest-group-id';
  const groupTraits = {
    'jest-group-trait-key-1': 'jest-group-trait-value-1',
    'jest-group-trait-key-2': 'jest-group-trait-value-2',
  };

  const originalXMLHttpRequest = window.XMLHttpRequest;

  afterEach(() => {
    jest.resetModules();
    jest.clearAllMocks();
    jest.restoreAllMocks();

    window.rudderanalytics = undefined;

    window.XMLHttpRequest = originalXMLHttpRequest;
  });

  describe('preload buffer', () => {
    it('should process the buffered API calls when SDK script is loaded', done => {
      // Mocking the xhr function
      window.XMLHttpRequest = jest.fn(() => xhrMock) as unknown as typeof XMLHttpRequest;

      loadingSnippet();
      window.rudderanalytics?.page();
      window.rudderanalytics?.ready(() => {
        expect((window.rudderanalytics as any).push).not.toBe(Array.prototype.push);

        // one source config endpoint call and one implicit page call
        expect(xhrMock.send).toHaveBeenCalledTimes(2);

        done();
      });

      require(pathToSdk);
    });
  });

  describe('api', () => {
    beforeEach(done => {
      // Mocking the xhr function
      window.XMLHttpRequest = jest.fn(() => xhrMock) as unknown as typeof XMLHttpRequest;

      loadingSnippet();

      window.rudderanalytics?.ready(() => {
        done();
      });

      require(pathToSdk);
    });

    it('should make network requests when event APIs are invoked', () => {
      window.rudderanalytics?.page();
      window.rudderanalytics?.track('test-event');
      window.rudderanalytics?.identify('jest-user');
      window.rudderanalytics?.group('jest-group');
      window.rudderanalytics?.alias('new-jest-user', 'jest-user');

      // one source config endpoint call and individual event requests
      expect(xhrMock.send).toHaveBeenCalledTimes(6);
    });

    describe('getAnonymousId', () => {
      it('should return a new UUID when no prior persisted data is present', () => {
        const anonId = window.rudderanalytics?.getAnonymousId();

        const uuidRegEx = /^[\da-f]{8}-[\da-f]{4}-4[\da-f]{3}-[\da-f]{4}-[\da-f]{12}$/i;
        expect(anonId).toMatch(uuidRegEx);
      });

      it('should persist the anonymous ID generated by the SDK', () => {
        const anonIdRes1 = window.rudderanalytics?.getAnonymousId();

        // SDK remembers the previously generated anonymous ID and returns the same value
        const anonIdRes2 = window.rudderanalytics?.getAnonymousId();

        expect(anonIdRes1).toEqual(anonIdRes2);
      });
    });

    describe('reset', () => {
      it('should clear all the persisted data except for anonymous ID when the flag is not set', () => {
        // Make identify and group API calls to let the SDK persist
        // user (ID and traits) and group data (ID and traits)
        window.rudderanalytics?.identify(userId, userTraits);
        window.rudderanalytics?.group(groupUserId, groupTraits);

        const anonId = 'jest-anon-ID';
        window.rudderanalytics?.setAnonymousId(anonId);

        // SDK clears all the persisted data except for anonymous ID
        window.rudderanalytics?.reset();

        // SDK remembers the previously generated anonymous ID and returns the same value
        const anonIdRes = window.rudderanalytics?.getAnonymousId();

        expect(anonId).toEqual(anonIdRes);
        expect(window.rudderanalytics?.getUserId()).toEqual('');
        expect(window.rudderanalytics?.getUserTraits()).toEqual({});
        expect(window.rudderanalytics?.getGroupId()).toEqual('');
        expect(window.rudderanalytics?.getGroupTraits()).toEqual({});
      });

      it('should clear all the persisted data include anonymous ID when the flag is set', () => {
        // Make identify and group API calls to let the SDK persist
        // user (ID and traits) and group data (ID and traits)
        window.rudderanalytics?.identify(userId, userTraits);
        window.rudderanalytics?.group(groupUserId, groupTraits);

        const anonId = 'jest-anon-ID';
        window.rudderanalytics?.setAnonymousId(anonId);

        // SDK clears all the persisted data
        window.rudderanalytics?.reset(true);

        // SDK remembers the previously generated anonymous ID and returns the same value
        const anonIdRes = window.rudderanalytics?.getAnonymousId();

        expect(anonId).not.toEqual(anonIdRes);
        expect(window.rudderanalytics?.getUserId()).toEqual('');
        expect(window.rudderanalytics?.getUserTraits()).toEqual({});
        expect(window.rudderanalytics?.getGroupId()).toEqual('');
        expect(window.rudderanalytics?.getGroupTraits()).toEqual({});
      });
    });
  });
});
