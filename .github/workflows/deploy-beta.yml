name: Deploy BETA/BugBash Feature

on:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.sha }}
  cancel-in-progress: true

permissions:
  id-token: write # allows the JWT to be requested from GitHub's OIDC provider
  contents: read # This is required for actions/checkout
  pull-requests: read # This is required to get PR information

env:
  NODE_OPTIONS: '--no-warnings'

jobs:
  get-deploy-inputs:
    name: Get Deploy Inputs
    runs-on: [self-hosted, Linux, X64]
    outputs:
      version_suffix: ${{ steps.deploy-inputs.outputs.version_suffix }}
      beta_identifier: ${{ steps.deploy-inputs.outputs.beta_identifier }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Find PR for current branch
        id: pr-info
        uses: actions/github-script@v6
        with:
          script: |
            const branch = context.ref.replace('refs/heads/', '');
            console.log(`Finding PRs for branch: ${branch}`);
            
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branch}`,
              base: 'develop',
              state: 'open'
            });
            
            if (pullRequests.length > 0) {
              const pr = pullRequests[0];
              const prNumber = pr.number.toString();
              console.log(`Found PR #${prNumber} for branch ${branch}: https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${prNumber}`);
              
              // Check if PR is in draft state
              if (pr.draft) {
                core.setFailed(`PR #${prNumber} is in draft state. Please mark it as ready for review before deploying.`);
                return;
              }
              
              // Get PR reviews
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              // Check for approvals
              const approvals = reviews.filter(review => {
                const username = review.user.login;
                // Exclude bot users and GitHub Copilot related accounts
                const isBotUser = review.user.type === 'Bot' ||
                                  /\[bot\]$/.test(username) ||
                                  /copilot/i.test(username) ||
                                  /code.*rabbit/i.test(username) ||
                                  ['github-actions', 'github-code-scanning'].includes(username);
                
                return review.state === 'APPROVED' && 
                       !isBotUser &&
                       // Check if this is the latest review from this user
                       !reviews.some(r => 
                         r.user.login === username && 
                         r.id > review.id && 
                         r.state !== 'APPROVED'
                       );
              });
              
              if (approvals.length === 0) {
                core.setFailed(`PR #${prNumber} requires at least one approval from a human reviewer before deploying.`);
                return;
              }
              
              console.log(`PR #${prNumber} has ${approvals.length} approval(s). Proceeding with beta deployment.`);
              console.log(`Approvals from: ${approvals.map(a => a.user.login).join(', ')}`);

              // Check if all required checks have passed
              const { data: checkRuns } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha,
                filter: 'latest'
              });
              
              // Get status checks from the commit status API as well (some CI systems use this instead of checks API)
              const { data: commitStatus } = await github.rest.repos.getCombinedStatusForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });
              
              // Get required status checks for the base branch
              const { data: branchProtection } = await github.rest.repos.getBranchProtection({
                owner: context.repo.owner,
                repo: context.repo.repo,
                branch: pr.base.ref
              }).catch(e => {
                console.log(`No branch protection found for ${pr.base.ref}: ${e.message}`);
                return { data: { required_status_checks: { contexts: [] } } };
              });
              
              const requiredChecks = branchProtection.required_status_checks?.contexts || [];
              
              // Check if any required checks have failed
              let failedChecks = [];
              
              // Check status API results
              if (commitStatus.state !== 'success') {
                failedChecks = commitStatus.statuses
                  .filter(status => status.state !== 'success')
                  .filter(status => requiredChecks.length === 0 || requiredChecks.includes(status.context))
                  .map(status => status.context);
              }
              
              // Check check runs API results
              const failedCheckRuns = checkRuns.check_runs
                .filter(check => check.conclusion !== 'success' && check.conclusion !== 'neutral')
                .filter(check => requiredChecks.length === 0 || requiredChecks.includes(check.name))
                .map(check => check.name);
              
              failedChecks = [...failedChecks, ...failedCheckRuns];
              
              if (failedChecks.length > 0) {
                core.setFailed(`PR #${prNumber} has failed checks: ${failedChecks.join(', ')}. All checks must pass before deploying.`);
                return;
              }

              core.setOutput('pr_number', prNumber);
            } else {
              core.setFailed(`No open PR found for branch ${branch} targeting develop branch`);
              core.setOutput('pr_number', '');
            }

      - name: Extract deploy inputs
        id: deploy-inputs
        shell: bash
        run: |
          echo "version_suffix=beta.pr.${{ steps.pr-info.outputs.pr_number }}" >> $GITHUB_OUTPUT
          echo "beta_identifier=PR-${{ steps.pr-info.outputs.pr_number }}" >> $GITHUB_OUTPUT

  deploy:
    if: false
    name: Deploy BETA/BugBash Feature
    uses: ./.github/workflows/deploy.yml
    needs: get-deploy-inputs
    with:
      environment: beta
      bugsnag_release_stage: beta
      s3_dir_path: beta/${{ needs.get-deploy-inputs.outputs.beta_identifier }}/v3
      s3_dir_path_legacy: beta/${{ needs.get-deploy-inputs.outputs.beta_identifier }}/v1.1
      action_type: ''
    secrets:
      AWS_ACCOUNT_ID: ${{ secrets.AWS_PROD_ACCOUNT_ID }}
      AWS_S3_BUCKET_NAME: ${{ secrets.AWS_PROD_S3_BUCKET_NAME }}
      AWS_S3_SYNC_ROLE: ${{ secrets.AWS_PROD_S3_SYNC_ROLE }}
      AWS_CF_DISTRIBUTION_ID: ${{ secrets.AWS_PROD_CF_DISTRIBUTION_ID }}
      BUGSNAG_API_KEY: ${{ secrets.RS_PROD_BUGSNAG_API_KEY }}
      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
      SLACK_RELEASE_CHANNEL_ID: ${{ secrets.SLACK_RELEASE_CHANNEL_ID_NON_PROD }}
